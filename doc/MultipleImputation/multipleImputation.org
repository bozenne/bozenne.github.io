#+TITLE: A simple example of multiple imputation using the mice package
#+Author: Brice Ozenne


This document gathers code from the documentation of the mice
package. See https://stefvanbuuren.name/mice/.

\bigskip

#+BEGIN_SRC R :exports none :results output :session *R* :cache no
setwd("c:/Users/hpl802/Documents/GitHub/bozenne.github.io/doc/MultipleImputation/")
#+END_SRC

#+RESULTS:

Load packages
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
library(lava)
library(mice)
library(data.table)
library(ggplot2)
#+END_SRC

#+RESULTS:

* Simulate data (just to have an example to work with)
Generative model
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
mSim <- lvm(Y~group+season+bmi+gender+age)
categorical(mSim, labels = c("winter","summer")) <- ~season
categorical(mSim, labels = c("SAD","HC")) <- ~group
categorical(mSim, labels = c("Male","Female")) <- ~gender
distribution(mSim,~bmi) <- lava::gaussian.lvm(mean = 22, sd = 3)
distribution(mSim,~age) <- lava::uniform.lvm(20,80)
#+END_SRC

#+RESULTS:

Sampling
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
n <- 1e2
set.seed(10)
dt.data <- as.data.table(sim(mSim,n))
#+END_SRC

#+RESULTS:
Add missing values
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
dt.data[1:10, bmi:=NA]
#+END_SRC

#+RESULTS:

\clearpage

* Working with mice

** Step 1: Inspect the missing data pattern
Check the number of missing values in the dataset:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
colSums(is.na(dt.data))
#+END_SRC

#+RESULTS:
:      Y  group season    bmi gender    age 
:      0      0      0     10      0      0

Missing data patterns:   
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
md.pattern(dt.data)
#+END_SRC
# #+BEGIN_SRC R :results graphics :file "./missingDataPattern.pdf" :exports results :session *R* :cache no
# md.pattern(dt.data)
# #+END_SRC

#+RESULTS:
[[file:./missingDataPattern.pdf]]

\clearpage

** Step 2: Define imputation model

#+BEGIN_SRC R :exports both :results output :session *R* :cache no
all.variables <- c("Y","group","season","bmi","gender","age")
n.variables <- length(all.variables)
Mlink <- matrix(0, n.variables, n.variables,
                dimnames = list(all.variables,all.variables))
Mlink[c("group","season","gender","age"),"bmi"] <- 1
Mlink
#+END_SRC

#+RESULTS:
:        Y group season bmi gender age
: Y      0     0      0   0      0   0
: group  0     0      0   1      0   0
: season 0     0      0   1      0   0
: bmi    0     0      0   0      0   0
: gender 0     0      0   1      0   0
: age    0     0      0   1      0   0

A value 1 indicates that the column variable was used to impute the
row variable, e.g. group was used to impute bmi.

\clearpage

** Step 3: Generate imputed datasets
Generate imputed values
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
n.imputed <- 3 ## number of imputed datasets
dt.mice <- mice(dt.data,
                m=n.imputed, 
                maxit = 50, # number of iterations to obtain the imputed dataset
                predictorMatrix = Mlink,
                method = 'pmm', # Predictive mean matching, only ok for continuous variables, it is possible to set constrains for positive variables
                seed = 500, printFlag = FALSE)
summary(dt.mice)
#+END_SRC

#+RESULTS:
#+begin_example
Class: mids
Number of multiple imputations:  3 
Imputation methods:
     Y  group season    bmi gender    age 
    ""     ""     ""  "pmm"     ""     "" 
PredictorMatrix:
       Y group season bmi gender age
Y      0     0      0   0      0   0
group  0     0      0   1      0   0
season 0     0      0   1      0   0
bmi    0     0      0   0      0   0
gender 0     0      0   1      0   0
age    0     0      0   1      0   0
#+end_example

\clearpage

** Step 4: Check the imputed datasets
*** Convergence of the imputation algorithm

#+BEGIN_SRC R :exports both :results output :session *R* :cache no
plot(dt.mice)
#+END_SRC   

#+RESULTS:

# #+BEGIN_SRC R :results graphics :file "./traceCVimputed.pdf" :exports results :session *R* :cache no
# plot(dt.mice)
# #+END_SRC

#+RESULTS:
[[file:./traceCVimputed.pdf]]

*** Visualizing the imputed values
Visualize imputed value values and check they are plausible (e.g. mice
is not imputed a BMI of 75):
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
dt.mice$imp$bmi
#+END_SRC

#+RESULTS:
#+begin_example
          1        2        3
1  20.15124 21.82216 20.90548
2  25.74547 24.76365 25.98147
3  21.27058 15.52519 26.41881
4  14.44499 23.83614 24.66090
5  24.51607 25.74547 21.08652
6  26.55555 22.05849 24.51607
7  20.97076 20.69408 25.02349
8  22.17178 17.51962 24.76365
9  17.60500 21.94247 26.41881
10 18.25130 22.05849 25.69917
#+end_example

The rows correspond to the 3 different imputed datasets and the
columns to 10 imputed values per dataset. One can also summarizes the
imputed values computing their quantiles:

#+BEGIN_SRC R :exports both :results output :session *R* :cache no
apply(dt.mice$imp$bmi,2,quantile)
#+END_SRC

#+RESULTS:
:             1        2        3
: 0%   14.44499 15.52519 20.90548
: 25%  18.72629 20.97610 24.55228
: 50%  21.12067 22.00048 24.89357
: 75%  23.93000 23.39173 25.91090
: 100% 26.55555 25.74547 26.41881

Boxplot of the imputed values:

#+BEGIN_SRC R :exports both :results output :session *R* :cache no
boxplot(dt.mice$imp$bmi)
#+END_SRC

# #+BEGIN_SRC R :results graphics :file "./boxplotImputed.pdf" :exports results :session *R* :cache no
# boxplot(dt.mice$imp$bmi)
# #+END_SRC

#+RESULTS:
[[file:./boxplotImputed.pdf]]

	Imputed values vs. observed values
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
dt.bmi <- rbind(data.table(bmi = unlist(dt.mice$imp$bmi), imputed = TRUE),
                data.table(bmi = na.omit(dt.data$bmi), imputed = FALSE))
#+END_SRC

#+RESULTS:

Histogram
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
gg1.bmi <- ggplot(dt.bmi, aes(bmi, group = imputed, fill = imputed))
gg1.bmi <- gg1.bmi + geom_histogram(aes(y=..count../sum(..count..)),position = "dodge")
gg1.bmi
#+END_SRC

#+RESULTS:
: `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.

# #+BEGIN_SRC R :results graphics :file "./histImputed.pdf" :exports results :session *R* :cache no
# gg1.bmi
# #+END_SRC

#+RESULTS:
[[file:./histImputed.pdf]]

One more plot:
   
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
stripplot(dt.mice, bmi~.imp, pch=20, cex=2)
#+END_SRC
# #+BEGIN_SRC R :results graphics :file "./striplotImputed.pdf" :exports results :session *R* :cache no
# stripplot(dt.mice, bmi~.imp, pch=20, cex=2)
# #+END_SRC

#+RESULTS:
[[file:./striplotImputed.pdf]]

\clearpage

** Step 3: Fit the statical model on each imputed dataset

#+BEGIN_SRC R :exports both :results output :session *R* :cache no
e.mice <- with(data = dt.mice,
               lm(Y~group+season+bmi+gender+age)
               )
e.mice
#+END_SRC

#+RESULTS:
#+begin_example
call :
with.mids(data = dt.mice, expr = lm(Y ~ group + season + bmi + 
    gender + age))

call1 :
mice(data = dt.data, m = n.imputed, method = "pmm", predictorMatrix = Mlink, 
    maxit = 50, printFlag = FALSE, seed = 500)

nmis :
     Y  group season    bmi gender    age 
     0      0      0     10      0      0 

analyses :
[[1]]

Call:
lm(formula = Y ~ group + season + bmi + gender + age)

Coefficients:
 (Intercept)       groupHC  seasonsummer           bmi  genderFemale           age  
      2.6716        0.7320        1.1417        0.8566        0.6350        1.0124  


[[2]]

Call:
lm(formula = Y ~ group + season + bmi + gender + age)

Coefficients:
 (Intercept)       groupHC  seasonsummer           bmi  genderFemale           age  
      2.1738        0.4821        1.2057        0.9066        0.6046        1.0020  


[[3]]

Call:
lm(formula = Y ~ group + season + bmi + gender + age)

Coefficients:
 (Intercept)       groupHC  seasonsummer           bmi  genderFemale           age  
      1.4529        0.3860        1.1272        0.9050        0.9807        1.0094
#+end_example

Check that using =with=:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
e.mice$analyses[[1]]
#+END_SRC

#+RESULTS:
: 
: Call:
: lm(formula = Y ~ group + season + bmi + gender + age)
: 
: Coefficients:
:  (Intercept)       groupHC  seasonsummer           bmi  genderFemale           age  
:       2.6716        0.7320        1.1417        0.8566        0.6350        1.0124

is equivalent to run the linear regression on the imputed dataset:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
dt.tempo <- copy(dt.data)
dt.tempo[is.na(bmi), bmi := dt.mice$imp$bmi[,1]]
lm(Y ~ group + season + bmi + gender + age, data  = dt.tempo)
#+END_SRC

#+RESULTS:
: 
: Call:
: lm(formula = Y ~ group + season + bmi + gender + age, data = dt.tempo)
: 
: Coefficients:
:  (Intercept)       groupHC  seasonsummer           bmi  genderFemale           age  
:       2.6716        0.7320        1.1417        0.8566        0.6350        1.0124

\clearpage

** Step 4: Pool the results over the imputed datasets

#+BEGIN_SRC R :exports both :results output :session *R* :cache no
ePool.mice <- pool(e.mice)
summary(ePool.mice)
#+END_SRC

#+RESULTS:
:               estimate  std.error statistic       df     p.value
: (Intercept)  2.0994178 1.53720448  1.365737 27.60999 0.175443034
: groupHC      0.5333769 0.42990642  1.240681 24.64629 0.217965151
: seasonsummer 1.1581844 0.37942876  3.052442 89.52004 0.002988004
: bmi          0.8894300 0.06542205 13.595263 21.64939 0.000000000
: genderFemale 0.7401163 0.44568379  1.660631 17.16642 0.100286406
: age          1.0079300 0.01217062 82.816644 20.68587 0.000000000


The (pooled) estimate is the average of the estimates relative to each
imputed dataset:
#+BEGIN_SRC R :exports both :results output :session *R* :cache n
Q.coef <- colMeans(do.call(rbind,lapply(e.mice$analyses, coef)))
Q.coef
#+END_SRC

#+RESULTS:
:  (Intercept)      groupHC seasonsummer          bmi genderFemale          age 
:    2.0994178    0.5333769    1.1581844    0.8894300    0.7401163    1.0079300

The variance is a bit more complex and involves:
- the within-imputation variance (depends on the sample size)
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
covW <- Reduce("+",lapply(e.mice$analyses, vcov))/n.imputed
covW
#+END_SRC

#+RESULTS:
:               (Intercept)       groupHC  seasonsummer           bmi  genderFemale           age
: (Intercept)   1.862431644 -0.0994440642 -0.0477903745 -6.786768e-02 -0.0961541467 -4.196538e-03
: groupHC      -0.099444064  0.1422982153  0.0119430572  2.070599e-03  0.0056222025 -5.605698e-04
: seasonsummer -0.047790374  0.0119430572  0.1416426832 -1.604466e-03  0.0129427682 -1.624194e-04
: bmi          -0.067867684  0.0020705988 -0.0016044660  3.202784e-03 -0.0001538781 -4.848575e-05
: genderFemale -0.096154147  0.0056222025  0.0129427682 -1.538781e-04  0.1404564390  2.433642e-04
: age          -0.004196538 -0.0005605698 -0.0001624194 -4.848575e-05  0.0002433642  1.096841e-04

- the between-imputation variance (depends on the amount of missin data)
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
ls.diffCoef <- lapply(e.mice$analyses, function(iI){coef(iI)-Q.coef})
covB <- Reduce("+",lapply(ls.diffCoef,tcrossprod))/(n.imputed-1)
covB
#+END_SRC

#+RESULTS:
:               [,1]          [,2]          [,3]          [,4]          [,5]          [,6]
: [1,]  0.3754244681  0.1025439091  0.0070478503 -0.0137914086 -0.1128631208  5.705877e-04
: [2,]  0.1025439091  0.0318909867 -0.0005751962 -0.0048485267 -0.0246900921  4.853229e-04
: [3,]  0.0070478503 -0.0005751962  0.0017426263  0.0004376612 -0.0060716948 -2.014883e-04
: [4,] -0.0137914086 -0.0048485267  0.0004376612  0.0008079455  0.0024361901 -1.127512e-04
: [5,] -0.1128631208 -0.0246900921 -0.0060716948  0.0024361901  0.0436332030  3.493617e-04
: [6,]  0.0005705877  0.0004853229 -0.0002014883 -0.0001127512  0.0003493617  2.882992e-05

- the simulation error
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
covE <- covB/n.imputed
covE
#+END_SRC

#+RESULTS:
:               [,1]          [,2]          [,3]          [,4]          [,5]          [,6]
: [1,]  0.1251414894  0.0341813030  2.349283e-03 -4.597136e-03 -0.0376210403  1.901959e-04
: [2,]  0.0341813030  0.0106303289 -1.917321e-04 -1.616176e-03 -0.0082300307  1.617743e-04
: [3,]  0.0023492834 -0.0001917321  5.808754e-04  1.458871e-04 -0.0020238983 -6.716278e-05
: [4,] -0.0045971362 -0.0016161756  1.458871e-04  2.693152e-04  0.0008120634 -3.758374e-05
: [5,] -0.0376210403 -0.0082300307 -2.023898e-03  8.120634e-04  0.0145444010  1.164539e-04
: [6,]  0.0001901959  0.0001617743 -6.716278e-05 -3.758374e-05  0.0001164539  9.609975e-06

The total variance is:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
covT <- covW + covB + covE
#+END_SRC

#+RESULTS:

leading to the standard errors:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
sqrt(diag(covT))
#+END_SRC
#+RESULTS:
:  (Intercept)      groupHC seasonsummer          bmi genderFemale          age 
:   1.53720448   0.42990642   0.37942876   0.06542205   0.44568379   0.01217062

# #+BEGIN_SRC R :exports both :results output :session *R* :cache no
# summary(ePool.mice)$std.error
# #+END_SRC

# #+RESULTS:
# : [1] 0.744297026 0.198790594 0.228668346 0.030690688 0.206315648 0.005623804

\clearpage

* Special case: imputation using a specific law and no covariate
Mice can be adapted in order, for instance, to sample from a uniform
distribution or a truncated normal distributioon. First define a
function doing the imputation:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
mice.impute.SI_uninf <- function(y, ry, ...){ ## uniform distribution
    n.NA <- sum(ry==FALSE)
    sample <- stats::runif(n.NA, min = 0, max = 1)
    return(cbind(sample))
}

mice.impute.SI_tnorm <- function(y, ry, ...){ ## truncated normal law
    require(truncnorm)
    n.NA <- sum(ry==FALSE)
    sample <- rtruncnorm(n.NA, a = 0, b = 1, mean = 1, sd = 0.1)
    return(cbind(sample))
}
#+END_SRC

#+RESULTS:

Then run mice as usual except that the method should correspond to one of the previous functions:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
n.imputed <- 50 ## number of imputed datasets
dt.mice2 <- mice(dt.data,
                m=n.imputed, 
                maxit = 1, # not relevant
                predictorMatrix = Mlink, # not relevant
                method = 'SI_tnorm', # function previous define (without "mice.impute.")
                seed = 500, printFlag = FALSE)
#+END_SRC

#+RESULTS:

Then as usual one should check that the imputed values are satisfying:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
quantile(unlist(dt.mice$imp$bmi))
#+END_SRC

#+RESULTS:
:        0%       25%       50%       75%      100% 
: 0.7041556 0.8790477 0.9317021 0.9687630 0.9997288

#+BEGIN_SRC R :exports both :results output :session *R* :cache no
hist(unlist(dt.mice2$imp$bmi))
#+END_SRC

# #+BEGIN_SRC R :results graphics :file "./histImputed2.pdf" :exports results :session *R* :cache no
# hist(unlist(dt.mice2$imp$bmi))
# #+END_SRC

#+RESULTS:
[[file:./histImputed2.pdf]]

One more plot:
#+BEGIN_SRC R :exports both :results output :session *R* :cache no
stripplot(dt.mice2, bmi~.imp, pch=20, cex=2)
#+END_SRC
# #+BEGIN_SRC R :results graphics :file "./striplotImputed2.pdf" :exports results :session *R* :cache no
# stripplot(dt.mice2, bmi~.imp, pch=20, cex=2)
# #+END_SRC

#+RESULTS:
[[file:./striplotImputed2.pdf]]

Here for instance the imputed values does not overlap the observed one
so something (i.e. the parameters of the distribution used for the
imputation) is wrong.

# \bigskip

# Then as before one can fit the statistical model using =with=:
# #+BEGIN_SRC R :exports both :results output :session *R* :cache no
# e.mice2 <- with(data = dt.mice2,
#                 lm(Y~group+season+bmi+gender+age)
#                 )
# ePool.mice2 <- pool(e.mice2)
# summary(ePool.mice2)
# #+END_SRC

# #+RESULTS:
# :                estimate  std.error statistic       df      p.value
# : (Intercept)  16.3571621 1.44891707 11.289233 92.05265 0.000000e+00
# : groupHC       0.3117620 0.64131399  0.486130 92.05265 6.280303e-01
# : seasonsummer  1.6171573 0.63762913  2.536204 92.05265 1.289066e-02
# : bmi           0.2207013 0.04502684  4.901550 92.05265 4.065644e-06
# : genderFemale  0.9072630 0.63710993  1.424029 92.05265 1.578191e-01
# : age           1.0209777 0.01772960 57.586060 92.05265 0.000000e+00

* Reporting guideline 
From https://stefvanbuuren.name/Winnipeg/Lectures/Winnipeg.pdf:
- Amount of missing data
- Reasons for missingness
- Differences between complete and incomplete data
- Method used to account for missing data
- Software
- Number of imputed datasets
- Imputation model
- Derived variables
- Diagnostics
- Pooling
- Listwise deletion
- Sensitivity analysis

* CONFIG :noexport:
# #+LaTeX_HEADER:\affil{Department of Biostatistics, University of Copenhagen, Copenhagen, Denmark}
#+LANGUAGE:  en
#+LaTeX_CLASS: org-article
#+LaTeX_CLASS_OPTIONS: [12pt]
#+OPTIONS:   title:t author:t toc:nil todo:nil
#+OPTIONS:   H:3 num:t 
#+OPTIONS:   TeX:t LaTeX:t

#+LATEX_HEADER: %
#+LATEX_HEADER: %%%% specifications %%%%
#+LATEX_HEADER: %

** Latex command
#+LATEX_HEADER: \usepackage{ifthen}
#+LATEX_HEADER: \usepackage{xifthen}
#+LATEX_HEADER: \usepackage{xargs}
#+LATEX_HEADER: \usepackage{xspace}

#+LATEX_HEADER: \newcommand\Rlogo{\textbf{\textsf{R}}\xspace} % 

** Notations

** Code
# Documentation at https://org-babel.readthedocs.io/en/latest/header-args/#results
# :tangle (yes/no/filename) extract source code with org-babel-tangle-file, see http://orgmode.org/manual/Extracting-source-code.html 
# :cache (yes/no)
# :eval (yes/no/never)
# :results (value/output/silent/graphics/raw/latex)
# :export (code/results/none/both)
#+PROPERTY: header-args :session *R* :tangle yes :cache no ## extra argument need to be on the same line as :session *R*

# Code display:
#+LATEX_HEADER: \RequirePackage{fancyvrb}
#+LATEX_HEADER: \DefineVerbatimEnvironment{verbatim}{Verbatim}{fontsize=\small,formatcom = {\color[rgb]{0.5,0,0}}}

# ## change font size input
# ## #+ATTR_LATEX: :options basicstyle=\ttfamily\scriptsize
# ## change font size output
# ## \RecustomVerbatimEnvironment{verbatim}{Verbatim}{fontsize=\tiny,formatcom = {\color[rgb]{0.5,0,0}}}

** Display 
#+LATEX_HEADER: \RequirePackage{colortbl} % arrayrulecolor to mix colors
#+LATEX_HEADER: \RequirePackage{setspace} % to modify the space between lines - incompatible with footnote in beamer
#+LaTeX_HEADER:\renewcommand{\baselinestretch}{1.1}
#+LATEX_HEADER:\geometry{top=1cm}

** Image
#+LATEX_HEADER: \RequirePackage{epstopdf} % to be able to convert .eps to .pdf image files
#+LATEX_HEADER: \RequirePackage{capt-of} % 
#+LATEX_HEADER: \RequirePackage{caption} % newlines in graphics

** Algorithm
#+LATEX_HEADER: \RequirePackage{amsmath}
#+LATEX_HEADER: \RequirePackage{algorithm}
#+LATEX_HEADER: \RequirePackage[noend]{algpseudocode}

** Math
#+LATEX_HEADER: \RequirePackage{dsfont}
#+LATEX_HEADER: \RequirePackage{amsmath,stmaryrd,graphicx}
#+LATEX_HEADER: \RequirePackage{prodint} % product integral symbol (\PRODI)

# ## lemma
# #+LaTeX_HEADER: \RequirePackage{amsthm}
# #+LaTeX_HEADER: \newtheorem{theorem}{Theorem}
# #+LaTeX_HEADER: \newtheorem{lemma}[theorem]{Lemma}

*** Template for shortcut
#+LATEX_HEADER: \newcommand\defOperator[7]{%
#+LATEX_HEADER:	\ifthenelse{\isempty{#2}}{
#+LATEX_HEADER:		\ifthenelse{\isempty{#1}}{#7{#3}#4}{#7{#3}#4 \left#5 #1 \right#6}
#+LATEX_HEADER:	}{
#+LATEX_HEADER:	\ifthenelse{\isempty{#1}}{#7{#3}#4_{#2}}{#7{#3}#4_{#1}\left#5 #2 \right#6}
#+LATEX_HEADER: }
#+LATEX_HEADER: }

#+LATEX_HEADER: \newcommand\defUOperator[5]{%
#+LATEX_HEADER: \ifthenelse{\isempty{#1}}{
#+LATEX_HEADER:		#5\left#3 #2 \right#4
#+LATEX_HEADER: }{
#+LATEX_HEADER:	\ifthenelse{\isempty{#2}}{\underset{#1}{\operatornamewithlimits{#5}}}{
#+LATEX_HEADER:		\underset{#1}{\operatornamewithlimits{#5}}\left#3 #2 \right#4}
#+LATEX_HEADER: }
#+LATEX_HEADER: }

#+LATEX_HEADER: \newcommand{\defBoldVar}[2]{	
#+LATEX_HEADER:	\ifthenelse{\equal{#2}{T}}{\boldsymbol{#1}}{\mathbf{#1}}
#+LATEX_HEADER: }

*** Shortcuts

**** Probability
#+LATEX_HEADER: \newcommandx\Cov[2][1=,2=]{\defOperator{#1}{#2}{C}{ov}{\lbrack}{\rbrack}{\mathbb}}
#+LATEX_HEADER: \newcommandx\Esp[2][1=,2=]{\defOperator{#1}{#2}{E}{}{\lbrack}{\rbrack}{\mathbb}}
#+LATEX_HEADER: \newcommandx\Prob[2][1=,2=]{\defOperator{#1}{#2}{P}{}{\lbrack}{\rbrack}{\mathbb}}
#+LATEX_HEADER: \newcommandx\Qrob[2][1=,2=]{\defOperator{#1}{#2}{Q}{}{\lbrack}{\rbrack}{\mathbb}}
#+LATEX_HEADER: \newcommandx\Var[2][1=,2=]{\defOperator{#1}{#2}{V}{ar}{\lbrack}{\rbrack}{\mathbb}}

#+LATEX_HEADER: \newcommandx\Binom[2][1=,2=]{\defOperator{#1}{#2}{B}{}{(}{)}{\mathcal}}
#+LATEX_HEADER: \newcommandx\Gaus[2][1=,2=]{\defOperator{#1}{#2}{N}{}{(}{)}{\mathcal}}
#+LATEX_HEADER: \newcommandx\Wishart[2][1=,2=]{\defOperator{#1}{#2}{W}{ishart}{(}{)}{\mathcal}}

#+LATEX_HEADER: \newcommandx\Likelihood[2][1=,2=]{\defOperator{#1}{#2}{L}{}{(}{)}{\mathcal}}
#+LATEX_HEADER: \newcommandx\Information[2][1=,2=]{\defOperator{#1}{#2}{I}{}{(}{)}{\mathcal}}
#+LATEX_HEADER: \newcommandx\Score[2][1=,2=]{\defOperator{#1}{#2}{S}{}{(}{)}{\mathcal}}

**** Operators
#+LATEX_HEADER: \newcommandx\Vois[2][1=,2=]{\defOperator{#1}{#2}{V}{}{(}{)}{\mathcal}}
#+LATEX_HEADER: \newcommandx\IF[2][1=,2=]{\defOperator{#1}{#2}{IF}{}{(}{)}{\mathcal}}
#+LATEX_HEADER: \newcommandx\Ind[1][1=]{\defOperator{}{#1}{1}{}{(}{)}{\mathds}}

#+LATEX_HEADER: \newcommandx\Max[2][1=,2=]{\defUOperator{#1}{#2}{(}{)}{min}}
#+LATEX_HEADER: \newcommandx\Min[2][1=,2=]{\defUOperator{#1}{#2}{(}{)}{max}}
#+LATEX_HEADER: \newcommandx\argMax[2][1=,2=]{\defUOperator{#1}{#2}{(}{)}{argmax}}
#+LATEX_HEADER: \newcommandx\argMin[2][1=,2=]{\defUOperator{#1}{#2}{(}{)}{argmin}}
#+LATEX_HEADER: \newcommandx\cvD[2][1=D,2=n \rightarrow \infty]{\xrightarrow[#2]{#1}}

#+LATEX_HEADER: \newcommandx\Hypothesis[2][1=,2=]{
#+LATEX_HEADER:         \ifthenelse{\isempty{#1}}{
#+LATEX_HEADER:         \mathcal{H}
#+LATEX_HEADER:         }{
#+LATEX_HEADER: 	\ifthenelse{\isempty{#2}}{
#+LATEX_HEADER: 		\mathcal{H}_{#1}
#+LATEX_HEADER: 	}{
#+LATEX_HEADER: 	\mathcal{H}^{(#2)}_{#1}
#+LATEX_HEADER:         }
#+LATEX_HEADER:         }
#+LATEX_HEADER: }

#+LATEX_HEADER: \newcommandx\dpartial[4][1=,2=,3=,4=\partial]{
#+LATEX_HEADER: 	\ifthenelse{\isempty{#3}}{
#+LATEX_HEADER: 		\frac{#4 #1}{#4 #2}
#+LATEX_HEADER: 	}{
#+LATEX_HEADER: 	\left.\frac{#4 #1}{#4 #2}\right\rvert_{#3}
#+LATEX_HEADER: }
#+LATEX_HEADER: }

#+LATEX_HEADER: \newcommandx\dTpartial[3][1=,2=,3=]{\dpartial[#1][#2][#3][d]}

#+LATEX_HEADER: \newcommandx\ddpartial[3][1=,2=,3=]{
#+LATEX_HEADER: 	\ifthenelse{\isempty{#3}}{
#+LATEX_HEADER: 		\frac{\partial^{2} #1}{\left( \partial #2\right)^2}
#+LATEX_HEADER: 	}{
#+LATEX_HEADER: 	\frac{\partial^2 #1}{\partial #2\partial #3}
#+LATEX_HEADER: }
#+LATEX_HEADER: } 

**** General math
#+LATEX_HEADER: \newcommand\Real{\mathbb{R}}
#+LATEX_HEADER: \newcommand\Rational{\mathbb{Q}}
#+LATEX_HEADER: \newcommand\Natural{\mathbb{N}}
#+LATEX_HEADER: \newcommand\trans[1]{{#1}^\intercal}%\newcommand\trans[1]{{\vphantom{#1}}^\top{#1}}
#+LATEX_HEADER: \newcommand{\independent}{\mathrel{\text{\scalebox{1.5}{$\perp\mkern-10mu\perp$}}}}
#+LaTeX_HEADER: \newcommand\half{\frac{1}{2}}
#+LaTeX_HEADER: \newcommand\normMax[1]{\left|\left|#1\right|\right|_{max}}
#+LaTeX_HEADER: \newcommand\normTwo[1]{\left|\left|#1\right|\right|_{2}}
